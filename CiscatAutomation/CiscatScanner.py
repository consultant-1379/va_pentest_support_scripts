import glob
import logging
import math
import os
import re
import sys
import threading
import time
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime

from PyQt5 import QtGui
from PyQt5.QtCore import Qt, QRunnable, QThreadPool, pyqtSignal, QObject, QMutex
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import (QApplication, QMainWindow, QTabWidget, QWidget, QGroupBox, QVBoxLayout, QHBoxLayout,
                             QGridLayout, QLabel, QComboBox, QPushButton, QTextEdit, QProgressBar,
                             QMessageBox, QListWidget, QListWidgetItem, QCheckBox, QDialog, QLineEdit)

from lib.ClassGetPENMInfo import PENMInfo
from lib.ClassGetVENMInfo import VENMInfo
from lib.ClassEnvInfo import EnvInfo
import utils.class_penm_utils as enm_utils
from  utils.CiscatScannerClass import CiscatScanner
import utils.new_report_generator as rg
import utils.GetReleaseSprint as rel
import utils.InitEnv as init
import utils.CiscatReportPersistence as persistence

class MainWindow(QMainWindow):

    def __init__(self, app: QApplication):
        super().__init__()
        logging.basicConfig(
            filename=os.path.join(os.path.expanduser('~'), 'scriptCiscat', 'ciscatexecutor.log'),
            level=logging.INFO,
            format='%(asctime)s.%(msecs)03d %(levelname)s %(module)s - [%(funcName)s]: %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S',
        )
        self.init_data()
        self.app = app
        self.is_stopping = False
        self.user_path = os.path.join(os.path.expanduser('~'), 'scriptCiscat')
        try:
            with open(os.path.join(self.user_path, 'lock_app'), 'x'):
                pass
        except FileExistsError:
            QMessageBox.information(self, 'Info', 'An instance of the application is already running.')
            exit(0)
        main_widget = QWidget()
        # Set window properties
        self.setWindowTitle("CISCAT Scanner")
        self.setGeometry(100, 100, 600, 400) # Set geometry (xPos, yPos, width, height)
        self.tab = QTabWidget()
        self.tab_info = QWidget()
        gradient = "background: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 1, stop: 0 white, stop: 1 lightgrey);"
        #self.tab_info.setStyleSheet(gradient)
        self.tab_scanner = QWidget()
        #self.tab_scanner.setStyleSheet(gradient)
        self.tab_report = QWidget()
        #self.tab_report.setStyleSheet(gradient)
        self.tab.addTab(self.tab_info, 'Info')
        self.tab.addTab(self.tab_scanner, 'Scanner')
        self.tab.addTab(self.tab_report, 'Report')

        self.text_info_log = QTextEdit()
        #self.text_info_log.setStyleSheet("background-color: #d7e5cb;")
        gradient = "background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 white, stop: 1 lightgrey);"
        self.text_info_log.setStyleSheet(gradient)
        self.text_info_log.setReadOnly(True)

        main_layout = QVBoxLayout()
        main_widget.setLayout(main_layout)
        main_layout.addWidget(self.tab)
        main_layout.addWidget(self.text_info_log)
        self.populate_info(self.tab_info)
        self.populate_scanner(self.tab_scanner)
        self.populate_report(self.tab_report)

        self.setCentralWidget(main_widget)
        self.threadpool = QThreadPool()
        self.threadpool.setMaxThreadCount(8)
        self.check_done_count = 0
        self.scan_counter = 0
        self.total_scan_counter = 0

        #define callbacks
        def on_tab_changed(index):
            print(f'Changed to {index}')
            if index == 1:

                tmp_target = self.cb_scan_target.currentIndex()
                tmp_instance = self.cb_scan_instance.currentIndex()
                self.cb_scan_target.setCurrentIndex(self.cb_target.currentIndex())
                self.cb_scan_instance.setCurrentIndex(self.cb_instance.currentIndex())
                if tmp_target == self.cb_scan_target.currentIndex() and tmp_instance == self.cb_scan_instance.currentIndex():
                    self.on_cb_scan_instance_changed(self.cb_scan_instance.currentIndex())


        # init widgets
        self.tab.currentChanged.connect(on_tab_changed)

    def closeEvent(self, event):
        reply = QMessageBox.question(self, 'Message',
                                     "Are you sure to quit?", QMessageBox.Yes |
                                     QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.Yes:
            event.accept()
            os.remove(os.path.join(self.user_path, 'lock_app'))
        else:
            event.ignore()
    def end_info_job(self, message, onError):
        self.log_message(message)
        self.app.setOverrideCursor(Qt.ArrowCursor)
        self.button_get_info.setDisabled(False)
        self.group_env2.setDisabled(onError)
        if not onError:
            self.utils = enm_utils.pENMUtils(self.cb_target.currentText(), self.cb_instance.currentText())
            self.cb_subnet.addItems(list(self.utils.ips_by_subnet.keys()))
            self.button_check_subnet.setDisabled(False)

    def log_message(self, message, color='green'):

        mutex = QMutex()
        mutex.lock()
        if isinstance(message, str):
            message = [message]
        for m in message:
            if 'error' in m.lower() or 'failed' in m.lower():
                color = 'red'
            str_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            self.text_info_log.append(f"[{str_date}] - <b style='color: {color};'>{m}<\b>")
            self.text_info_log.moveCursor(self.text_info_log.textCursor().End)  # Move the cursor to the end
            self.text_info_log.ensureCursorVisible()
        mutex.unlock()

    def init_data(self):
        self.info = EnvInfo()
        self.penm_info = PENMInfo()
        self.venm_info = VENMInfo()

    def get_is_stopping(self):
        return self.is_stopping
    def populate_info(self, tab: QWidget):

        # Widgets definition
        h_layout = QHBoxLayout()
        tab.setLayout(h_layout)
        grid_layout_1 = QGridLayout()
        grid_layout_2 = QGridLayout()
        self.group_env1 = QGroupBox('Env data')
        #self.group_env1.setStyleSheet("background-color: #fdfbd3;")
        self.group_env2 = QGroupBox('Check')
        label_target = QLabel('Target')
        self.cb_target = QComboBox()
        label_instance = QLabel('Instance')
        self.cb_instance = QComboBox()
        self.button_get_info = QPushButton('Get Info')
        label_subnet = QLabel('Subnet')
        self.cb_subnet = QComboBox()
        b_clear_props = QPushButton('Clear properties')
        self.b_clear_reports = QPushButton('Clear reports')

        self.button_check_subnet = QPushButton('Check IPs and generate properties')
        self.progress_bar = QProgressBar()
        self.progress_bar.setValue(0)

        def on_clear_props():
            list_props = self.get_properties_list(self.cb_target.currentText(), self.cb_instance.currentText())
            counter_removed = 0
            counter_fail_removing = 0
            for prop in list_props:
                try:
                    os.remove(prop)
                    counter_removed += 1
                except Exception as err:
                    print(f'Error removing {prop}: {err}')
                    counter_fail_removing += 1
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle(f'Remove Properties Files for {self.cb_target.currentText()} { self.cb_instance.currentText()}')
            msg_box.setText(f'Removed {counter_removed} Failed {counter_fail_removing}')
            msg_box.exec_()
            update_button_string_props_counter()

        def on_clear_reports():
            files = [f for f in os.listdir(os.path.join(self.user_path, 'reports', self.cb_target.currentText(),
                                                        self.cb_instance.currentText())) if f.endswith('.csv') or f.endswith('.xml') or f.endswith('.html')]
            counter_removed = 0
            counter_fail_removing = 0
            for f in files:
                try:
                    os.remove(os.path.join(self.user_path, 'reports', self.cb_target.currentText(),
                                           self.cb_instance.currentText(), f))
                    counter_removed += 1
                except Exception as err:
                    print(f'Error removing {f}: {err}')
                    counter_fail_removing += 1
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle(f'Remove reports Files (csv) for {self.cb_target.currentText()} { self.cb_instance.currentText()}')
            msg_box.setText(f'Removed {counter_removed} Failed {counter_fail_removing}')
            msg_box.exec_()
            self.update_button_string_reports_counter()

        # Event callbacks
        def on_cb_target_changed(index):
            self.cb_subnet.clear()
            self.progress_bar.setValue(0)
            self.button_check_subnet.setDisabled(True)
            self.cb_instance.clear()
            self.cb_instance.addItems(self.info.getInstancesList(self.cb_target.currentText()))
            update_button_string_props_counter()

        def on_cb_instance_changed(index):
            self.cb_subnet.clear()
            self.progress_bar.setValue(0)
            self.button_check_subnet.setDisabled(True)
            update_button_string_props_counter()
            self.update_button_string_reports_counter()

        def info_job():
            if self.cb_target.currentText() in ['vENM_', 'siENM_']:
                return
            else:
                try:
                    self.app.setOverrideCursor(Qt.WaitCursor)
                    self.button_get_info.setDisabled(True)
                    pool = QThreadPool.globalInstance()
                    runnable = RunnableInfo(self, self.cb_target.currentText())
                    pool.start(runnable)
                except Exception as err:
                    self.log_message(err)
                    # messagebox.showinfo("Result", err)
                    # combobox_subnet['state'] = 'disabled'
                    # button_ipFiltering['state'] = 'disabled'

        def on_button_get_info():
            self.cb_subnet.clear()
            self.progress_bar.setValue(0)
            self.text_info_log.clear()
            info_job()

        def on_check_ip_end(str):
            self.log_message(str)
            print(f'completion : {self.current_check_counter} / {len(self.ips_list)}')
            self.progress_bar.setValue(math.floor(self.current_check_counter/len(self.ips_list)*100))
            self.current_check_counter += 1
            if self.progress_bar.value() == 100:
                self.group_env1.setDisabled(False)
                self.group_env2.setDisabled(False)
                update_button_string_props_counter()

        def on_button_check_subnet():
            self.current_check_counter = 1
            self.group_env1.setDisabled(True)
            self.group_env2.setDisabled(True)
            self.results = []
            self.progress_bar.setValue(0)

            self.ips_list = self.utils.ips_by_subnet[self.cb_subnet.currentText()]


            # self.selected_ips = self.utils.find_addresses_in_subnet(self.iplist,
            #                                               self.cb_subnet.currentText().split('=')[1])
            # self.params = utils.ssh_connectivity_check(self.selected_ips,
            #                                       os.path.join(self.user_path, 'resources',
            #                                                    self.cb_target.currentText(),
            #                                                    self.cb_instance.currentText()))
            for p in self.ips_list:
                runnable = RunnableCheckIps(self, p)
                runnable.signal.completed.connect(on_check_ip_end)
                self.threadpool.start(runnable)

        def update_button_string_props_counter():
            props = self.get_properties_list(self.cb_target.currentText(), self.cb_instance.currentText())
            b_clear_props.setText(f'Clear properties ({len(props)} files)')

        grid_layout_1.addWidget(label_target, 0, 0)
        grid_layout_1.addWidget(self.cb_target, 0, 1)
        grid_layout_1.addWidget(label_instance, 1, 0)
        grid_layout_1.addWidget(self.cb_instance, 1, 1)
        grid_layout_1.addWidget(self.button_get_info, 2, 0, 1, 2)
        grid_layout_1.addWidget(b_clear_props, 3, 0)
        grid_layout_1.addWidget(self.b_clear_reports, 3, 1)
        grid_layout_2.addWidget(label_subnet, 0, 0)
        grid_layout_2.addWidget(self.cb_subnet, 0, 1)
        grid_layout_2.addWidget(self.button_check_subnet, 1, 0, 1, 2)
        grid_layout_2.addWidget(self.progress_bar, 2, 0, 1, 2)

        self.group_env1.setLayout(grid_layout_1)
        self.group_env2.setLayout(grid_layout_2)
        h_layout.addWidget(self.group_env1)
        h_layout.addWidget(self.group_env2)
        h_layout.setAlignment(Qt.AlignTop)
        grid_layout_1.setAlignment(Qt.AlignTop)
        grid_layout_2.setAlignment(Qt.AlignLeft)

        #init widgets
        self.cb_target.addItems(self.info.getTargetsList())
        self.cb_instance.addItems(self.info.getInstancesList(self.cb_target.currentText()))
        self.cb_target.currentIndexChanged.connect(on_cb_target_changed)
        self.cb_instance.currentIndexChanged.connect(on_cb_instance_changed)
        self.button_get_info.clicked.connect(on_button_get_info)
        self.button_check_subnet.clicked.connect(on_button_check_subnet)
        b_clear_props.clicked.connect(on_clear_props)
        self.b_clear_reports.clicked.connect(on_clear_reports)
        self.cb_subnet.setFixedWidth(220)
        self.group_env2.setDisabled(True)
        self.text_info_log.clear()
        update_button_string_props_counter()
        self.update_button_string_reports_counter()

    def update_button_string_reports_counter(self):
        c = [f for f in os.listdir(os.path.join(self.user_path, 'reports', self.cb_target.currentText(),
                                                self.cb_instance.currentText())) if f.endswith('.csv')]
        self.b_clear_reports.setText(f'Clear Reports ({len(c)})')
    def populate_scanner(self, tab: QWidget):
        g_layout = QGridLayout()
        tab.setLayout(g_layout)
        group_env = QGroupBox('Env data')
        group_props = QGroupBox('Properties')
        self.listWidget = QListWidget()
        button_select_all = QPushButton('Select All')
        button_unselect_all = QPushButton('Unselect All')
        button_refresh = QPushButton('Refresh')
        buttons_layout = QHBoxLayout()
        v_env_layout = QVBoxLayout()
        h2_env_layout = QHBoxLayout()
        prop_layout = QVBoxLayout()
        prop_layout.addWidget(self.listWidget)
        prop_layout.addLayout(buttons_layout)
        group_props.setLayout(prop_layout)
        scan_progress = QProgressBar()
        g_layout.addWidget(group_env, 0, 0)
        g_layout.addWidget(group_props, 0, 1, 2, 1)
        legend_v_layout = QVBoxLayout()
        l_red = QLabel('Error')
        l_red.setAlignment(Qt.AlignCenter)
        l_red.setStyleSheet("background-color: red; font-weight: bold;")
        l_orange = QLabel('Warning')
        l_orange.setStyleSheet("background-color: orange; font-weight: bold;")
        l_orange.setAlignment(Qt.AlignCenter)
        l_yellow = QLabel('Running')
        l_yellow.setStyleSheet("background-color: yellow; font-weight: bold;")
        l_yellow.setAlignment(Qt.AlignCenter)
        l_green = QLabel('Ended')
        l_green.setStyleSheet("background-color: green; font-weight: bold;")
        l_green.setAlignment(Qt.AlignCenter)
        legend_v_layout.addWidget(l_red)
        legend_v_layout.addWidget(l_orange)
        legend_v_layout.addWidget(l_yellow)
        legend_v_layout.addWidget(l_green)
        g_layout.addLayout(legend_v_layout, 1, 0)
        layout = QHBoxLayout()
        #group_env.setFixedHeight(100)
        group_env.setLayout(v_env_layout)
        v_env_layout.addLayout(layout)
        v_env_layout.addLayout(h2_env_layout)
        h2_env_layout.addWidget(scan_progress)
        layout.setAlignment(Qt.AlignTop)
        g_layout.setAlignment(Qt.AlignTop)
        label_target = QLabel('Target')
        self.cb_scan_target = QComboBox()
        self.cb_scan_target.addItems(self.info.getTargetsList())
        label_instance = QLabel('Instance')
        self.cb_scan_instance = QComboBox()
        button_run_scan = QPushButton('Run Ciscat Scan')
        button_stop_scan = QPushButton('Stop Ciscat Scan')

        layout.addWidget(label_target)
        layout.addWidget(self.cb_scan_target)
        layout.addWidget(label_instance)
        layout.addWidget(self.cb_scan_instance)

        buttons_layout.addWidget(button_run_scan)
        buttons_layout.addWidget(button_stop_scan)
        buttons_layout.addWidget(button_refresh)
        buttons_layout.addWidget(button_select_all)
        buttons_layout.addWidget(button_unselect_all)

        # Event callbacks
        def on_cb_scan_target_changed(index):
            self.cb_scan_instance.clear()
            self.cb_scan_instance.addItems(self.info.getInstancesList(self.cb_scan_target.currentText()))

        def on_click_select_all():
            self.set_all_checkboxes(True)

        def on_click_unselect_all():
            self.set_all_checkboxes(False)

        def on_click_refresh():
            self.on_cb_scan_instance_changed(0)

        def on_scan_end(res):
            self.scan_counter += 1
            percentage = math.floor(self.scan_counter / self.total_scan_counter * 100)
            scan_progress.setValue(percentage)
            exit_code, vm_name, total_time = res.split('|')
            logging.info(f'OnScanEnd for VM {vm_name}')
            filename = os.path.join(self.user_path, 'reports', self.cb_scan_target.currentText(),
                                    self.cb_scan_instance.currentText(), 'logs', vm_name + '.log')
            ret = get_exit_code(filename)
            logging.info(f'OnScanEnd got exit code for VM {vm_name}')
            if not ret:
                color = 'red'
            elif ret[0] == 0:
                color = 'green'
            else:
                color = 'orange'
            set_item_background_color('     ' + vm_name + '.properties', color)
            if ret:
                self.log_message(
                    f'Scanning ended for vm {vm_name} in {total_time} minutes. Exit Code={ret[0]} Exit Value={ret[1]}',
                    color=color)
            else:
                if exit_code == '-1':
                    self.log_message(
                        f'Scanning on vm {vm_name} skipped.', color=color)
                else:
                    self.log_message(
                        f'Scanning ended for vm {vm_name} in {total_time} minutes. {exit_code}', color=color)
            if self.scan_counter == self.total_scan_counter:
                self.is_stopping = False
                # Disable buttons
                controls_disabling_for_scan_execution(False)
                self.update_button_string_reports_counter()
            logging.info(f'OnScanEnd exiting method for VM {vm_name}')

        def on_scan_start(prop_file):
            set_item_background_color('     ' + prop_file, 'yellow')

        def set_item_background_color(item_text, color):
            print()
            for index in range(self.listWidget.count()):
                item = self.listWidget.item(index)
                if item.text() == item_text:
                    item.setBackground(QtGui.QColor(color))

        def controls_disabling_for_scan_execution(enabling):
            self.tab.setTabEnabled(0, not enabling)
            self.tab.setTabEnabled(2, not enabling)
            self.cb_scan_target.setDisabled(enabling)
            self.cb_scan_instance.setDisabled(enabling)
            button_run_scan.setDisabled(enabling)
            button_refresh.setDisabled(enabling)

        def on_button_run_scan():
            button_stop_scan.setDisabled(False)
            # Remove old log files
            files = self.get_log_list(self.cb_scan_target.currentText(), self.cb_scan_instance.currentText())
            for file in files:
                try:
                    os.remove(file)
                except Exception as err:
                    print(f'Error removing log file: {err}')

            self.scan_counter = 0
            props_list = self.get_checked_items()
            if len(props_list) == 0:
                return
            scan_progress.setValue(0)
            # Disable buttons
            controls_disabling_for_scan_execution(True)
            #self.tab.setDisabled(True)
            legend_v_layout.setEnabled(True)
            print(f'{self.cb_scan_target.currentText()} / {self.cb_scan_instance.currentText()}')
            self.ciscat_scanner = CiscatScanner(self.cb_scan_target.currentText(), self.cb_scan_instance.currentText())
            #ciscat_scanner.execute_command()(cb_target

            self.total_scan_counter = len(props_list)
            for p in props_list:
                #set_item_background_color(p, 'yellow')
                complete_path = os.path.join(self.user_path, 'resources', self.cb_scan_target.currentText(),
                                             self.cb_scan_instance.currentText(), 'properties', p.strip())
                runnable = RunnableRunScanner(self, complete_path, self.get_is_stopping)
                runnable.signal.completed.connect(on_scan_end)
                runnable.signal.started.connect(on_scan_start)
                self.threadpool.start(runnable)

        def on_properties_double_clicked(item):
            dialog = QDialog(parent=self)
            #dialog.setFixedSize(600, 400)
            dialog.setWindowTitle(item.text().strip())
            dialog.setWindowFlags(dialog.windowFlags() & ~Qt.WindowContextHelpButtonHint)

            layout = QVBoxLayout(dialog)
            text_edit = QTextEdit()
            font = text_edit.font()
            font.setPointSize(10)  # adjust size as needed
            text_edit.setFont(font)
            text_edit.setReadOnly(True)
            layout.addWidget(text_edit)
            with open(os.path.join(self.user_path, 'resources', self.cb_scan_target.currentText(),
                                   self.cb_scan_instance.currentText(), 'properties', item.text().strip())) as f:
                text_edit.setText(f.read())
            close_button = QPushButton('Close')
            close_button.clicked.connect(dialog.close)
            layout.addWidget(close_button)
            dialog.show()

        def get_exit_code(filename):
            try:
                with open(filename, 'r') as file:
                    exit_value = 0
                    for line in file:
                        match_exit_value = re.search(r' Exit Value: (\d+)', line)
                        if match_exit_value:
                            exit_value = match_exit_value.group(1)
                        match_exit_code = re.search(r'Exiting; Exit Code: (\d+)', line)
                        if match_exit_code:
                                return (int(match_exit_code.group(1)), int(exit_value))
            except Exception as err:
                pass
            return None

        def on_button_stop():
            self.is_stopping = True
            button_stop_scan.setDisabled(True)

        # init widgets
        button_select_all.clicked.connect(on_click_select_all)
        button_unselect_all.clicked.connect(on_click_unselect_all)
        button_refresh.clicked.connect(on_click_refresh)
        self.cb_scan_target.currentIndexChanged.connect(on_cb_scan_target_changed)
        self.cb_scan_instance.addItems(self.info.getInstancesList(self.cb_scan_target.currentText()))
        #self.on_cb_scan_instance_changed(self.cb_scan_instance.currentIndex())
        button_run_scan.clicked.connect(on_button_run_scan)
        button_stop_scan.clicked.connect(on_button_stop)
        button_stop_scan.setDisabled(True)
        self.cb_scan_instance.currentIndexChanged.connect(self.on_cb_scan_instance_changed)
        self.listWidget.itemDoubleClicked.connect(on_properties_double_clicked)
        scan_progress.setValue(0)
        on_cb_scan_target_changed(self.cb_scan_target.currentIndex())

    def populate_report(self, tab: QWidget):
        v_layout = QVBoxLayout()
        v_layout.setAlignment(Qt.AlignTop)
        tab.setLayout(v_layout)
        layout_group_report_env = QHBoxLayout()
        layout_group_report_env.setAlignment(Qt.AlignLeft)
        self.group_report_env = QGroupBox('Env Selection')
        self.label_report_env_target = QLabel('Target')
        self.cb_report_env_target = QComboBox()
        self.label_report_env_instance = QLabel('Instance')
        self.cb_report_env_instance = QComboBox()

        v_layout.addWidget(self.group_report_env)
        self.group_report_env.setLayout(layout_group_report_env)
        layout_group_report_env.addWidget(self.label_report_env_target)
        layout_group_report_env.addWidget(self.cb_report_env_target)
        layout_group_report_env.addWidget(self.label_report_env_instance)
        layout_group_report_env.addWidget(self.cb_report_env_instance)

        layout_report_env_info = QGridLayout()
        self.group_report_env_info = QGroupBox('Env Info')

        v_layout.addWidget(self.group_report_env_info)
        self.group_report_env_info.setLayout(layout_report_env_info)
        self.group_report_env_info.setFixedWidth(300)
        self.label_report_env_info_report_name = QLabel('Report Name')
        self.label_report_env_info_ciscat_version = QLabel('Ciscat Version')
        self.label_report_env_info_enm_iso_version = QLabel('ENM ISO Version')
        self.label_report_env_info_release = QLabel('Release/Sprint')
        self.entry_report_env_info_report_name = QLineEdit()
        self.entry_report_env_info_report_name.setPlaceholderText('Insert here the report file name')
        self.entry_report_env_info_ciscat_version = QLineEdit()
        self.entry_report_env_info_ciscat_version.setPlaceholderText('Insert here the CISCAT version')
        self.entry_report_env_info_enm_iso_version = QLineEdit()
        self.entry_report_env_info_enm_iso_version.setPlaceholderText('Insert here the ENM ISO version')
        # self.entry_report_env_info_release = QLineEdit()
        # self.entry_report_env_info_release.setPlaceholderText('Insert here the release')
        # self.entry_report_env_info_sprint = QLineEdit()
        # self.entry_report_env_info_sprint.setPlaceholderText('Insert here the sprint')
        self.cb_report_env_info_release = QComboBox()
        #self.cb_report_env_info_sprint = QComboBox()

        layout_report_env_info.addWidget(self.label_report_env_info_report_name, 0 , 0)
        layout_report_env_info.addWidget(self.label_report_env_info_ciscat_version, 1, 0)
        layout_report_env_info.addWidget(self.label_report_env_info_enm_iso_version, 2, 0)
        layout_report_env_info.addWidget(self.label_report_env_info_release, 3, 0)
        #layout_report_env_info.addWidget(self.label_report_env_info_sprint, 4, 0)
        layout_report_env_info.addWidget(self.entry_report_env_info_report_name, 0 , 1)
        layout_report_env_info.addWidget(self.entry_report_env_info_ciscat_version, 1, 1)
        layout_report_env_info.addWidget(self.entry_report_env_info_enm_iso_version, 2, 1)
        layout_report_env_info.addWidget(self.cb_report_env_info_release, 3, 1)
        #layout_report_env_info.addWidget(self.cb_report_env_info_sprint, 4, 1)
        self.button_report_generate_report = QPushButton('Generate Report')

        # Only for test - to be removed

        self.button_report_persist = QPushButton('Persist Report')

        v_layout.addWidget(self.button_report_generate_report)
        v_layout.addWidget(self.button_report_persist)

        # Define callbacks

        def on_select_report_target(target):
            print(self.cb_report_env_target.itemText(target))
            self.cb_report_env_instance.clear()
            self.cb_report_env_instance.addItems(self.info.getInstancesList(self.cb_report_env_target.itemText(target)))

        def on_click_generate_report():
            rel_sprint = self.cb_report_env_info_release.currentText()
            match = re.search(r'[^\.\d]*(\d+\.\d+)[^\.\d]*(\d+\.\d+)[^\.\d]*', rel_sprint)

            if (self.entry_report_env_info_report_name.text().strip() == ''
                    or self.entry_report_env_info_enm_iso_version.text().strip() == ''
                    or self.entry_report_env_info_ciscat_version.text().strip() == ''):
                QMessageBox.information(self, 'Info', 'All info must be provided.')
                return
            if match:
                release = match.group(1)
                sprint = match.group(2)
            else:
                QMessageBox.information(self, 'Info', 'Wrong Release/Sprint')
                return
            folder_path = os.path.join(self.user_path, 'reports', self.cb_report_env_target.currentText(),
                                       self.cb_report_env_instance.currentText())
            file_dialog = FileSelectionDialog(folder_path, self)
            selected_files = file_dialog.exec_()
            if selected_files:

                report_file_name = rg.generates_report(self.cb_report_env_target.currentText(),
                                                       self.cb_report_env_instance.currentText(),
                                                       self.entry_report_env_info_report_name.text(),
                                                       self.entry_report_env_info_ciscat_version.text(),
                                                       self.entry_report_env_info_enm_iso_version.text(),
                                                       release, sprint, selected_files)
                self.log_message(f'Report saved in {report_file_name}')
                QMessageBox.information(self, 'Info', f'Report generated correctly.')

        def on_click_persist_report():
            file_to_persist = os.path.join(self.user_path, 'reports', self.cb_report_env_target.currentText(),
                                           self.cb_report_env_instance.currentText(), 'report', 'report.xlsx')
            if not os.path.isfile(file_to_persist):
                QMessageBox.information(self, 'Error', f'File {file_to_persist} not exists.')
                return
            try:
                persistence.persist(file_to_persist, 'db\\ciscat_report.db')
                QMessageBox.information(self, 'Info', 'DB updated.')
            except Exception as err:
                QMessageBox.information(self, 'Error', f'Error persisting file {file_to_persist} : {err}')

        # Init widgets

        self.cb_report_env_target.addItems(self.info.getTargetsList())
        self.cb_report_env_instance.addItems(self.info.getInstancesList(self.cb_report_env_target.currentText()))
        self.cb_report_env_target.currentIndexChanged.connect(on_select_report_target)
        self.button_report_generate_report.clicked.connect(on_click_generate_report)
        self.button_report_persist.clicked.connect(on_click_persist_report)
        self.button_report_persist.setDisabled(True)
        try:
            rels = rel.getSprintReleaseList()
            self.cb_report_env_info_release.addItems(rel.getSprintReleaseList())
        except:
            self.cb_report_env_info_release.setEditable(True)

    def get_checked_items(self):
        checked_items = []
        for index in range(self.listWidget.count()):
            item = self.listWidget.item(index)
            checkbox = self.listWidget.itemWidget(item)
            if checkbox.isChecked():
                checked_items.append(item.text())
        return checked_items

    def set_all_checkboxes(self, state):
        for index in range(self.listWidget.count()):
            item = self.listWidget.item(index)
            checkbox = self.listWidget.itemWidget(item)
            checkbox.setChecked(state)

    def get_properties_list(self, target, instance):
        return glob.glob(
            os.path.join(self.user_path, 'resources', target, instance, 'properties', '*.properties'))

    def get_log_list(self, target, instance):
        return glob.glob(
            os.path.join(self.user_path, 'reports', target, instance, 'logs', '*.log'))

    def on_cb_scan_instance_changed(self, index):
        print('Called on instance changed')
        self.listWidget.clear()
        props = self.get_properties_list(self.cb_scan_target.currentText(), self.cb_scan_instance.currentText())
        print(len(props))
        for prop in props:
            item = QListWidgetItem('     ' + os.path.basename(prop))
            self.listWidget.addItem(item)
            checkbox = QCheckBox()
            checkbox.setChecked(True)
            self.listWidget.setItemWidget(item, checkbox)


class WorkerSignal(QObject):
    completed = pyqtSignal(str)


class ScannerSignal(QObject):
    started = pyqtSignal(str)
    completed = pyqtSignal(str)


class RunnableInfo(QRunnable):
    def __init__(self, main_class:MainWindow, env_type):

        super().__init__()
        self.main_class = main_class
        self.env_type = env_type
        
    def run(self):
        if self.env_type == 'pENM':
            lmihost = self.main_class.info.getDictionary('pENM')[self.main_class.cb_instance.currentText()][0]
            lmiuser = self.main_class.info.getDictionary('pENM')[self.main_class.cb_instance.currentText()][1]
            lmipassword = self.main_class.info.getDictionary('pENM')[self.main_class.cb_instance.currentText()][2]
            try:
                self.main_class.log_message(f'Getting sed anf key files for {self.main_class.cb_target.currentText()} '
                                            f'{self.main_class.cb_instance.currentText()}')
                result = self.main_class.penm_info.retrieve_files(lmihost, lmiuser, lmipassword,
                                                                  self.main_class.cb_instance.currentText())
                self.main_class.end_info_job(result, False)
            except Exception as err:
                self.main_class.end_info_job(str(err), True)
        elif self.env_type == 'vENM' or self.env_type== 'siENM':
            try:
                self.main_class.log_message(f'Getting sed anf key files for {self.main_class.cb_target.currentText()} '
                                            f'{self.main_class.cb_instance.currentText()}')
                # TODO - Manage errors and exceptions
                result = self.main_class.venm_info.getInfo(self.main_class.cb_target.currentText(),
                                                           self.main_class.cb_instance.currentText())
                self.main_class.end_info_job(result, False)
            except Exception as err:
                self.main_class.end_info_job(str(err), True)



class RunnableCheckIps(QRunnable):
    def __init__(self, main_class:MainWindow, ip):
        super().__init__()
        self.signal = WorkerSignal()
        self.ip = ip
        self.main_class = main_class

    def run(self):
        try:
            res = self.main_class.utils.properties_4_host(self.ip)
            self.signal.completed.emit(res)
        except Exception as err:
            print(err)


class RunnableRunScanner(QRunnable):
    def __init__(self, main_class:MainWindow, properties_file, stopping_callback):
        super().__init__()
        self.signal = ScannerSignal()
        self.main_class = main_class
        self.properties_file = properties_file
        self.is_stopping = stopping_callback
    def run(self):
        logging.info(f'Starting scanner for {os.path.basename(self.properties_file)}')
        t0 = time.time()
        self.signal.started.emit(os.path.basename(self.properties_file))
        if self.is_stopping():
            logging.info(f'Skipping scanner for {os.path.basename(self.properties_file)}')
            self.signal.completed.emit(f'-1|{os.path.splitext(os.path.basename(self.properties_file))[0]}|0')
        else:
            res = self.main_class.ciscat_scanner.execute_command(self.properties_file)
            tot_time = math.floor((time.time() - t0)/60)
            logging.info(f'Ending scanner for {os.path.basename(self.properties_file)}')
            self.signal.completed.emit(f'{str(res)}|{os.path.splitext(os.path.basename(self.properties_file))[0]}|{str(tot_time)}')


class FileSelectionDialog(QDialog):
    def __init__(self, folder_path, parent=None):
        super(FileSelectionDialog, self).__init__(parent)
        # font = QFont('Arial', 12)
        # self.setFont(font)
        self.setWindowTitle('Select CSV Files for report')
        # self.setGeometry(100, 100, 500, 300)
        self.folder_path = folder_path
        self.selected_files = []

        layout = QVBoxLayout()

        self.list_widget = QListWidget()
        self.populate_list_widget()

        button_layout = QHBoxLayout()
        select_all_button = QPushButton('Select All')
        select_all_button.clicked.connect(self.select_all)
        unselect_all_button = QPushButton('Unselect All')
        unselect_all_button.clicked.connect(self.unselect_all)
        ok_button = QPushButton('OK')
        ok_button.clicked.connect(self.accept)
        cancel_button = QPushButton('Cancel')
        cancel_button.clicked.connect(self.reject)

        button_layout.addWidget(select_all_button)
        button_layout.addWidget(unselect_all_button)
        button_layout.addWidget(ok_button)
        button_layout.addWidget(cancel_button)

        layout.addWidget(self.list_widget)
        layout.addLayout(button_layout)

        self.setLayout(layout)

    def populate_list_widget(self):
        files = [f for f in os.listdir(self.folder_path) if f.endswith('.csv')]
        self.setWindowTitle(f'Select CSV Files for report (total : {len(files)})')
        for file in files:
            item = QListWidgetItem()
            checkbox = QCheckBox()
            checkbox.setText(file)
            self.list_widget.addItem(item)
            self.list_widget.setItemWidget(item, checkbox)

    def select_all(self):
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            checkbox = self.list_widget.itemWidget(item)
            checkbox.setChecked(True)

    def unselect_all(self):
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            checkbox = self.list_widget.itemWidget(item)
            checkbox.setChecked(False)

    def exec_(self):
        result = super(FileSelectionDialog, self).exec_()
        if result:
            for i in range(self.list_widget.count()):
                item = self.list_widget.item(i)
                checkbox = self.list_widget.itemWidget(item)
                if checkbox.isChecked():
                    self.selected_files.append(checkbox.text())
            return self.selected_files
        else:
            return None


def main():
    init.initializeScriptingCiscat()
    app = QApplication(sys.argv)
    #app.setStyle('Fusion')

    mainWin = MainWindow(app)
    mainWin.show()

    sys.exit(app.exec_())

if __name__ == '__main__':
    main()