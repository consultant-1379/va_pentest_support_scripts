import glob
import json
import logging
import os
import configparser
import re
import subprocess
import time


class CiscatScanner:
    def __init__(self, target, instance):
        logging.basicConfig(
            filename=os.path.join(os.path.expanduser('~'), 'scriptCiscat', 'ciscatexecutor.log'),
            level=logging.INFO,
            format='%(asctime)s.%(msecs)03d %(levelname)s %(module)s - [%(funcName)s]: %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S',
        )
        self._target = target
        self._instance = instance
        self.BASE_PATH = os.path.join(os.path.expanduser('~'), 'scriptCiscat')
        self._load_os_mapping()
        self._load_properties_list()

    def _create_ciscat_command(self, property_file_path):
        pattern = r'#os=(.+)\n'
        with open(property_file_path) as prop:
            content = prop.read()
        mtc = re.search(pattern, content)
        if mtc:
            os_version = mtc.group(1).strip()
        else:
            raise Exception(f'Unable to read OS version from {property_file_path}')
        if not os_version in self.os_mapper.keys():
            raise Exception(f'Unable to map {os_version} in mapping file for {property_file_path}')
        benchmark = self.os_mapper[os_version]['benchmark']
        profile = self.os_mapper[os_version]['profile']
        return [
               'C:\\Users\\Public\\Documents\\assessor\\Assessor-CLI.bat',
               '-b',
               os.path.join('C:\\Users\\Public\\Documents\\assessor\\benchmarks', benchmark),
               '-p',
               profile,
               '-sessions',
               property_file_path,
               '-rd',
               os.path.join(self.BASE_PATH, 'reports', self._target, self._instance),
               '-csv',
               '-html'
        ]

    def _load_os_mapping(self):
        with open(os.path.join(self.BASE_PATH, 'os-benchmark-mapping.json'), 'r') as file:
            self.os_mapper = json.load(file)

    def _load_properties_list(self):
        self.properties_file_list = glob.glob(
            os.path.join(self.BASE_PATH, 'resources', self._target, self._instance, 'properties',
                         '*.properties'))

    def execute_command(self, property_file_path):
        t0 = time.time()
        try:
            command = self._create_ciscat_command(property_file_path)
            command_output_path = os.path.join(self.BASE_PATH, 'reports', self._target, self._instance, 'logs',
                                               os.path.splitext(os.path.basename(property_file_path))[0] + '.log')
        except Exception as err:
            return err

        with open(command_output_path, 'w') as command_output:
            try:
                logging.info(
                    f'Running subprocess for {os.path.basename(property_file_path)}')
                print( f'Running subprocess for {os.path.basename(property_file_path)}')
                print(f'Running command {command}')
                result = subprocess.run(command, text=True, stdout=command_output, check=True, timeout=1800)

            except subprocess.CalledProcessError as err:
                logging.info(
                    f'Exception CalledProcessError for subprocess {os.path.basename(property_file_path)} err:{err}')
                return err

            except subprocess.TimeoutExpired as err:
                logging.info(
                    f'Exception Timeout for subprocess {os.path.basename(property_file_path)} err :{err}')
                return 'Timeout Exceeded'

            except subprocess.SubprocessError as err:
                logging.info(
                    f'Exception SubprocessError for subprocess {os.path.basename(property_file_path)} err :{err}')
                return err

            except Exception as err:
                logging.info(
                    f'Exception exception for subprocess {os.path.basename(property_file_path)} err :{err}')
                return err

            command_output.write(f'Errors -> {result.stderr}\n')
            command_output.write(f'Return code -> {result.returncode}\n')
            ex_time = int((time.time()-t0)/60)
            command_output.write(f'Execution time -> {ex_time} minutes\n')

        # return the output and the exit code as a tuple
        return result.returncode

if __name__ == '__main__':
    test = CiscatScanner('pENM', '596')

    test._load_properties_list()
    print(test.execute_command(test.properties_file_list[0]))
