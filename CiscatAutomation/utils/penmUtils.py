import concurrent.futures
import glob
import json
import logging
import math
import os
import re
import ipaddress
import subprocess
import time
import paramiko
import socket
from paramiko.ssh_exception import SSHException

SUDO_FLAG = True
my_path = os.path.join(os.path.expanduser('~'), 'scriptCiscat')
assessor_path = 'C:\\Users\\Public\\Documents\\assessor'
counter = 0
logg = open('completemapping.txt', 'a')

logging.basicConfig(
    filename=os.path.join(os.path.expanduser('~'), 'scriptCiscat', 'execscan.log'),
    level=logging.INFO,
    format='%(asctime)s.%(msecs)03d %(levelname)s %(module)s - [%(funcName)s]: %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
)
def extract_ips_from_file(file_path):

    pattern = re.compile(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b')
    # Open the file and read its contents
    with open(file_path, 'r') as file:
        contents = file.read()
    # Match all instances of the IP address pattern in the contents
    matches = re.findall(pattern, contents)
    # Return a list of the matched IP addresses
    return matches

def find_addresses_in_subnet(ip_list, subnet):

    # Initialize an empty list to store the found IP addresses
    addresses = []
    # Convert the subnet to an IPv4Network object
    subnet_mask = ipaddress.IPv4Network(subnet)
    # Check each IP address in the list to see if it's in the subnet
    for ip in ip_list:
        if ipaddress.IPv4Address(ip) in subnet_mask:
            addresses.append(ip)
    # Return the list of IP addresses in the subnet
    return addresses

def extract_cidr_subnet_definitions_from_file(file_path):
    """
    Extract subnet definitions in CIDR notation from a text file and return a list.

    :param file_path: str - Absolute path of the text file
    :return: list - List of subnet definitions in CIDR notation extracted from the file
    """

    # Compile a regular expression pattern to match CIDR subnet definitions
    pattern = re.compile(r'.+\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/\d{1,2}')

    # Open the file and read its contents
    with open(file_path, 'r') as file:
        contents = file.read()

    # Match all instances of the CIDR subnet definition pattern in the contents
    matches = re.findall(pattern, contents)

    # Return the list of matched subnet definitions
    return matches

def remove_duplicates(input_list):
    """
    Remove all duplicated elements from a list and return the modified list.

    :param input_list: list - The list to remove duplicates from
    :return: list - The modified list with all duplicates removed
    """

    # Convert the list to a set to remove duplicates
    unique_set = set(input_list)

    # Convert the set back to a list
    unique_list = list(unique_set)

    # Return the modified list with all duplicates removed
    return unique_list

def ssh_connectivity_check(ip_list, credential_file_path, progress_cbk):

    out_list = []
    # Read the contents of the credentials file into a list of tuples
    credential_list = []
    with open(os.path.join(credential_file_path, 'credentials.txt'), 'r') as f:
        for line in f:
            if line.strip() == '':
                continue
            items = line.strip().split()
            credential_list.append(tuple([i.split("=")[1] for i in items]))
    # Loop through each IP address in the list and try to connect via SSH
    counter = 1
    for ip in ip_list:
        print(f'Check {counter} of {len(ip_list)}')
        progress_cbk(100 * counter / len(ip_list))
        counter += 1
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        result = ''
        # Try to connect to the remote machine using the credentials file
        for credential in credential_list:
            try:
                print(f'Trying {credential[0]} / {credential[1]}')
                # Try to connect to the machine using the credentials
                if credential[0] == 'cloud-user':
                    k = paramiko.RSAKey.from_private_key_file(os.path.join(credential_file_path, credential[1]))
                    ssh.connect(ip, username=credential[0], pkey=k, timeout=6, banner_timeout=6)
                    stdin, stdout, stderr = ssh.exec_command("hostname")
                    output = stdout.read().decode().strip('\n')

                    #read os version
                    stdin, stdout, stderr = ssh.exec_command("cat /etc/os-release")
                    tmp = stdout.read().decode()

                    name_match = re.search(r'PRETTY_NAME="([^"]+)"', tmp)
                    #version_match = re.search(r'VERSION_ID="([^"]+)"', tmp)

                    #if name_match and version_match:
                    if name_match:
                        name = name_match.group(1)
                        print("Name:", name)
                    else:
                        print("Name and/or Version not found in the input string")
                        name = 'no_name'

                    result = f"{output},{ip},{credential[0]},{credential[1]},{name}"
                    out_list.append(result)
                    logg.write(result+'\n')
                    ssh.close()
                    break
                else:
                    ssh.connect(ip, username=credential[0], password=credential[1], timeout=6, banner_timeout=200)
                    stdin, stdout, stderr = ssh.exec_command("hostname")
                    output = stdout.read().decode().strip('\n')
                    #read os version
                    stdin, stdout, stderr = ssh.exec_command("cat /etc/os-release")
                    tmp = stdout.read().decode()

                    name_match = re.search(r'PRETTY_NAME="([^"]+)"', tmp)
                    #version_match = re.search(r'VERSION_ID="([^"]+)"', tmp)

                    #if name_match and version_match:
                    if name_match:
                        name = name_match.group(1)
                        print("Name:", name)
                    else:
                        print("Name and/or Version not found in the input string")
                        name = 'no_name'

                    result = f"{output},{ip},{credential[0]},{credential[1]},{name}"
                    out_list.append(result)
                    logg.write(result + '\n')
                    if credential[0] == 'litp-admin' and SUDO_FLAG:
                        shell = ssh.invoke_shell()
                        shell.send("su root\n")
                        while not 'Password' in shell.recv(1024).decode():
                            pass
                        shell.send('12shroot' + "\n")
                        out = shell.recv(1024).decode()
                        while not 'litp-admin' in out:
                            out = shell.recv(1024).decode()
                        shell.send('usermod -aG wheel litp-admin' + '\n')
                        out = shell.recv(1024).decode()
                        while not 'litp-admin' in out:
                            out = shell.recv(1024).decode()
                    ssh.close()
                    break
            except  paramiko.SSHException as e:
                print(f'Error paramiko.SSHException for {ip} credential  {credential[0]},{credential[1]} --> {e}')
                out_list.append(f'FAILED ip={ip}: {e}')
            except TimeoutError as e:
                print(f'Error TimeoutError for {ip} credential  {credential[0]},{credential[1]} --> {e}')
                out_list.append(f'FAILED ip={ip}: {e}')
                break
    return out_list

def post_processing(vm_list):
    #f = open('processed_426.txt', 'w')
    processed = []
    pattern = r'^(\D+)\-(\d+)\-([^ ]+)'
    newlist = []
    for entry in vm_list:
        if 'FAILED' in entry:
            continue
        part = entry.split(',')[0]
        token = re.match(pattern, part)
        if token:
            newlist.append(f'{token.group(3)}-{token.group(1)}-{token.group(2)},{",".join(entry.split(',')[1:])}')
        else:
            newlist.append(entry)
    newlist.sort()
    pattern=r'^([^ ]+)-(\D+)-(\d+)'
    last = ''
    last_no_token = ''
    for e in newlist:
        pre = e.split(',')[0]
        token = re.match(pattern, pre)
        if token:
            if token.group(1)!=last:
                #f.write(e+'\n')
                processed.append(f'{token.group(2)}-{token.group(3)}-{token.group(1)},{",".join(e.split(',')[1:])}')
                last = token.group(1)
        elif pre != last_no_token:
            processed.append(e)
            last_no_token = pre
    return processed

def split_hosts_list(full_list, chunk:int, files_path):
    if chunk < 1 :
        raise Exception(f'Invalid chunk size {chunk}')
    l = len(full_list)
    if l == 0:
        raise Exception(f'Wrong list size, the ip list is empty, check the connections')
    #num_of_files = math.ceil(l / chunk)

    file_list = glob.glob(os.path.join(files_path, 'host_list_*'))
    for file_path in file_list:
        try:
            os.remove(file_path)
            print(f"Removed file: {file_path}")
        except OSError as e:
            print(f"Error removing file: {file_path} - {e}")


    count = 1
    file_index = 1
    for row in full_list:
        if count == 1 :
            f = open(os.path.join(files_path, f'host_list_{file_index}'), 'w+')
        f.write(f'{row}\n')
        if count == chunk:
            count = 1
            file_index+=1
            f.close()
        else:
            count+=1

def convert_file(input_file, output_file, target, instance):
    '''

    :param input_file: path of file containing host parameters per line
    :param output_file: properties file path readable by CISCAT
    :return: None
    '''
    with open(input_file, 'r') as infile:
        lines = infile.readlines()

    with open(output_file, 'w') as outfile:
        index = 1
        for line in lines:
            hostname, ipaddress, username, password, os_version = line.strip().split(',')
            outfile.write(f"session.{index}.type=ssh\n")
            outfile.write(f"session.{index}.host={ipaddress}\n")
            outfile.write(f"session.{index}.user={username}\n")

            if username == "cloud-user":
                key_file = os.path.join(my_path, 'resources', target, instance, password).replace('\\', '\\\\')
                outfile.write(f"session.{index}.identity={key_file}\n")
            else:

                outfile.write(f"session.{index}.cred={password}\n")
            outfile.write(f"session.{index}.port=22\n")
            outfile.write(f"#session.{index}.tmp=path\n\n")
            outfile.write(f"#os={os_version}\n")
            index += 1

def test():
    global counter
    counter+=1

def execute_command(data):
    command = data[0]
    output = data[1]
    logger = data[2]
    progress = data[3]
    test()
    t0 = time.time()
    with open(output, 'w') as f:
        logging.info(f'logging to {output}')
        logger(f'Executing {progress} : \n{command}')
        logging.info(f'Running subprocess  : {command}')
        try:
            result = subprocess.run(command, text=True, stdout=f, check=True)
        except subprocess.CalledProcessError as err:
            f.write(f'CISCAT exited with error : {err}\n')
        except subprocess.SubprocessError as err:
            f.write(f'Error executing CISCAT batch file : {err}\n')
        except Exception as err:
            f.write(f'Unexpected error executing CISCAT : {err}\n')
        logging.info(f'Ended  subprocess : {command}')
        # f.write(f'Errors -> {result.stderr}\n')
        # f.write(f'Return code -> {result.returncode}\n')
        ex_time = int((time.time()-t0)/60)
        f.write(f'Execution time -> {ex_time} minutes\n')
        logger(f'Ended {progress} : \n{command}  Execution time -> {ex_time} minutes')

    # return the output and the exit code as a tuple
    print(f'End of {output}. Executed in {ex_time} minutes')
    return result.returncode

def find_benchmark(filename, os):
    with open(filename) as f:
        # Load JSON data from file
        data = json.load(f)

    # Now you can access your data as a Python object
    for i in data:
        if i['os'] == os:
            return i['benchmark']

def extract_os(filename):
    with open(filename, 'r') as file:
        for line in file:
            # Remove leading and trailing spaces and check if it starts with '#os'
            stripped_line = line.strip()
            if stripped_line.startswith('#') and 'os' in stripped_line:
                key, value = stripped_line.split('=', 1)  # Split the line into key and value at the first equals sign
                return value.strip()  # Remove leading and trailing spaces from the value
def create_ciscat_command(benchmark, profile, sessions_properties, report_path):
    return [
           'C:\\Users\\Public\\Documents\\assessor\\Assessor-CLI.bat',
           '-b',
           benchmark,
           '-p',
           profile,
           '-sessions',
           sessions_properties,
           '-rd',
           report_path,
           '-csv',
           '-html'
    ]

def run_job(target, instance, logger, benchmark='CIS_Red_Hat_Enterprise_Linux_7_Benchmark_v4.0.0-xccdf.xml', profile='"Level 2 - Server"'):

    to_remove = glob.glob(os.path.join(my_path, 'reports', target, instance, '*'))
    for file_path in to_remove:
        try:
            os.remove(file_path)
            print(f"Removed file: {file_path}")
        except OSError as e:
            print(f"Error removing file: {file_path} - {e}")

    property_files = [os.path.abspath(file) for file in glob.glob(os.path.join(my_path, 'resources', target, instance,
                                                                      'properties', '*.properties'))]
    benchmark = os.path.join(assessor_path, 'benchmarks', benchmark)
    profile = profile
    reports_path = os.path.join(my_path, 'reports', target, instance)
    commands = []
    for sess_prop in property_files:
        cmd = ' '.join(create_ciscat_command(benchmark, profile, sess_prop, reports_path))
        commands.append(cmd)
    jobs = []
    for c in commands:
        progress = f'{len(jobs)+1} of {len(commands)}'
        jobs.append([c, os.path.join(reports_path, f'log_{len(jobs)+1}.txt'), logger, progress])
    t0 = time.time()
    try:
        with concurrent.futures.ThreadPoolExecutor(max_workers=6) as executor:
            executor.map(execute_command, jobs)
    except Exception as err:
        logging.info(f'Exception from threadpool executor {err}')


    logger("**execution*ended**")

    print(f'Time = {int((time.time()-t0)/60)}')

if __name__ == '__main__':
    pass

